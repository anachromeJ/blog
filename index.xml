<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jincheng Li</title>
    <link>http://jinchengli.me/</link>
    <description>Recent content on Jincheng Li</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 19 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://jinchengli.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PostgreSQL Query Optimization (Work In Progress)</title>
      <link>http://jinchengli.me/post/postgres-internals/</link>
      <pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jinchengli.me/post/postgres-internals/</guid>
      <description>

&lt;p&gt;The other day I saw a tweet about blog posts it would be great to see, and one of them was &amp;ldquo;inside PostgreSQL: how a join works internally, what makes it fast&amp;rdquo;. Coincidentally, I&amp;rsquo;m taking a course on database system implementation, and I thought this would be a great way to study for my midterm! Of course, by the time I&amp;rsquo;ve finished this post, the midterm is long gone, but it was still a great incentive for me to start writing :)&lt;/p&gt;

&lt;h2 id=&#34;background:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Background&lt;/h2&gt;

&lt;p&gt;This post assumes you know a little something about relational databases and SQL queries. Having some knowledge in query optimization certainly helps, but is not necessary.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.postgresql.org/about&#34;&gt;PostgreSQL&lt;/a&gt;, or Postgres, is an open-source object-relational database management system. It has gone through around 30 years of development, has a ton of features, and is very popular within the database community. The fact that it is open-source makes it a great candidate system to study and write an article about. This post will only focus on its query optimization routines, particularly how it optimizes join queries. If you are curious, though, you should definitely check out the source code for yourself and read about its architecture.&lt;/p&gt;

&lt;h2 id=&#34;query-optimization-101:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Query Optimization 101&lt;/h2&gt;

&lt;p&gt;We all know that we can run SQL queries through a DBMS, and these queries are &lt;em&gt;pretty&lt;/em&gt; fast (no really), but how does a DBMS go about evaluating these queries? How does it take advantage of the indexes on tables to speed up queries? This is where query optimization comes in. Query optimization is the process of determining the best evaluation plan for a query, based on a limited amount of information about a database (e.g. metadata of its tables).&lt;/p&gt;

&lt;p&gt;Given a SQL query, a query optimizer typically determines the best plan in two steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;generate (a subset of) all possible plans&lt;/li&gt;
&lt;li&gt;evaluate the cost of each plan, and pick the one with the lowest cost&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The details of how each DBMS chooses to implement steps 1 and 2 vary, but this 2-step process applies to most relational query optimizers, including Postgres. In order to understand this process, we need to know a little bit more about query evaluation plans, algorithms for evaluating relational operators, and analysis of costs. Let&amp;rsquo;s start with query evaluation plans.&lt;/p&gt;

&lt;h3 id=&#34;query-evaluation-plans:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Query Evaluation Plans&lt;/h3&gt;

&lt;p&gt;A query evaluation plan describes how a query should be evaluated, by specifying the order of relational operators and the algorithms to use for each operator. For example, suppose we have a query involving a join and a selection condition. One possible query evaluation plan for this is to do the join first, using the nested loops join algorithm, and then as tuples come out of the join, filter them with the selection condition.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s talk about a concrete example. Suppose we have a database about Oscar nominations, with the following tables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE Movies (
  mid int PRIMARY KEY,
  title text NOT NULL
);

CREATE TABLE People (
  pid int PRIMARY KEY,
  name text NOT NULL
);
  
CREATE TABLE Nominees (
  pid int,
  mid int,
  year int NOT NULL,
  won bool NOT NULL,
  PRIMARY KEY (pid, mid)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a SQL query that finds the names of all movies nominated in 2016:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT m.title
FROM Movies m, Nominees n
WHERE m.mid = n.mid AND n.year = 2016;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One possible evaluation plan for this query is to join Movies and Nominees first with nested loops join, and then filter the results one tuple at a time with the selection condition &lt;code&gt;n.year = 2016&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Query evaluation plans are typically represented as trees, where each node of the tree represents a table that is either readily available in the database, or the result of an operation. Nodes are accordingly annotated with either the name of the table in the database, or the relational operator and the corresponding method of evaluation. For the movie query above, the query evaluation plan would be represented as:&lt;/p&gt;

&lt;!-- TODO: insert diagram here, and maybe use a different example --&gt;

&lt;h3 id=&#34;algorithms-for-relational-operators-mostly-joins:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Algorithms for Relational Operators (Mostly Joins)&lt;/h3&gt;

&lt;p&gt;Now that we know how query plans are structured, we can go into more detail on the specific algorithms for evaluating relational operators. Before doing this, we need to have some meaningful measure of the performance of an algorithm. Conventionally, in a DBMS, the cost of an operation is considered in terms of the number of disk page I/Os. If some operation in a query plan reads two pages and writes one page, then its cost would be 3 I/Os. Postgres adopts a similar cost model, although a bit more nuisanced. It records not just the total cost of an operation, but also the start-up cost - the setup cost of the operation before the first row can be returned. The start-up cost is useful for cases like an &lt;code&gt;EXISTS&lt;/code&gt; clause or a &lt;code&gt;LIMIT&lt;/code&gt; clause, where the query executor will stop after fetching the first couple of rows. For our discussion of algorithms here, cost simply refers to the total I/O cost.&lt;/p&gt;

&lt;h4 id=&#34;everything-except-joins:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Everything Except Joins&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll briefly talk about relational operators other than join first. There are three major relational operators: selection, projection and join. It&amp;rsquo;s usually straightforward to do selection and projection. For selection, you have one of two choices - use an index, or scan the entire table. The cost of using an index varies depending on the kind of index available and the number of rows returned, but the cost estimation is simple. For projection, if there is no DISTINCT keyword, you simply scan the table and retrieve a subset of the fields of each tuple. If &lt;code&gt;DISTINCT&lt;/code&gt; is specified, then typically you would sort the table and discard duplicates. The more interesting aspect of optimizing selections and projections is trying to find an optimal ordering of these operations with respect to other operations (like join). We can choose to do a projection first, and then join the resulting table with another table, or we can join first and then project later.&lt;/p&gt;

&lt;p&gt;There are other relational operators including aggregation using &lt;code&gt;GROUP BY&lt;/code&gt;, and set operations. Aggregation is usually done by sorting the table first, and then scanning the sorted tuples while updating an in-memory counter. Set operations are similar to projection with &lt;code&gt;DISTINCT&lt;/code&gt;, in that the expensive part is duplicate elimination. Again, this is typically implemented through sorting.&lt;/p&gt;

&lt;h4 id=&#34;joins:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;Joins&lt;/h4&gt;

&lt;p&gt;Finally, our main concern in this post - the join operator. There are a number of different algorithms for performing joins: nested loops join, block nested loops join, index nested loops join, sort merge join, and hash join. Figuring out the best query evaluation plan typically amounts to enumerating all the different orders in which you can join tables, and then choosing the best join algorithm for each join. For our discussion here, let&amp;rsquo;s suppose we are joining two tables A and B, where A has $p_A$ pages and $n_A$ rows, and B has  $p_B$ pages and $n_B$ rows. We&amp;rsquo;ll go over the join algorithms one by one.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Nested Loops Join&lt;/p&gt;

&lt;p&gt;Nested loops join is the brute-force algorithm that would come to mind when you first hear the definition of a join - it does a cross-product of the two tables, and filters the result with the join condition. Thus for each row in the outer table, the inner table has to be scanned in its entirety.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Block Nested Loops Join&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Index Nested Loops Join&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort Merge Join&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hash Join&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;the-postgres-query-optimizer:909bee48cea3b78afa7b2d1d59f0a47c&#34;&gt;The Postgres Query Optimizer&lt;/h2&gt;

&lt;p&gt;With all the background knowledge out of the way, we can dive into the specifics of PostgreSQL&amp;rsquo;s query optimizer. In a typical database class (e.g. the one I&amp;rsquo;m taking at Columbia), you will learn that most query optimizers adopt the tradition of the &amp;ldquo;System R Query Optimizer&amp;rdquo;, which was a research project at IBM some time ago. This is largely true, but not exactly true in the case of Postgres. When enumerating query plans, the System R Optimizer would only consider &amp;ldquo;left-deep&amp;rdquo; plans, i.e. plans where only the left-subtree can be the result of a join, and the right subtree must be a table that exists in the database. The purpose of this restriction is to reduce the exponential space of possible query plans. It is still exponential after this reduction, but much more manageable. In the case of Postgres, however, in addition to left-deep plans, right-deep plans and &amp;ldquo;bushy&amp;rdquo; plans are also considered.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why This Blog</title>
      <link>http://jinchengli.me/post/first-post/</link>
      <pubDate>Sun, 13 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jinchengli.me/post/first-post/</guid>
      <description>&lt;p&gt;This is probably my last year as a student, when I still have a lot of freedom allocating my time. In the hopes of putting my spare time to better use than playing Witcher 3 and Hearthstone, I decided to start writing some technical articles. This would be a good opportunity for me to do some research into things I never dedicate enough time to understand, and hopefully benefit whoever chances upon this little blog :)&lt;/p&gt;

&lt;p&gt;Also I haven&amp;rsquo;t tried to start a website for ~3 years now, and as I&amp;rsquo;m starting to find out, it&amp;rsquo;s &lt;em&gt;unbelievably&lt;/em&gt; easy to spin up something like this. No wonder everyone has their own blog these days and they all look so pretty (I&amp;rsquo;m currently using Hugo, Github Pages and Namecheap for this site).&lt;/p&gt;

&lt;p&gt;Cheers!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>